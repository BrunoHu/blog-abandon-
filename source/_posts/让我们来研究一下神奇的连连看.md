title: 让我们来研究一下神奇的连连看
date: 2015-09-26 01:20:47
tags:
- 算法
- 数据结构
- 游戏
---
找个小游戏来学习练习一下构建模型，练练看结构简约而不简单，刚刚好，就拿来练练手，下一期说不定是数独，我觉得那个也挺有意思的~

在下面的文章里，把连连看里的小方快都叫做**结点**，这样能够统一数据结构和通俗的叫法，不易混淆。

# 模型
我们可以总结一下连连看这个游戏的规则来构建模型：

1. 当所有的结点都被消去时，游戏结束。
2. 两个结点之间如果图案相同而且存在一条路径上没有其他结点，而且这条路径转弯的粗书不超过两次，那么这两个结点称为相连的。
3. 相连的结点可消去，消去后所在位置为空。
4. 当不存在相连结点并且还有结点存在时，称为死锁状态，应自动调换所有结点的位置。

那么，根据连连看的规则，这个游戏只有三个状态：

1. 存在可以连的结点。
2. 死锁状态。
3. 没有结点，游戏结束。

而这三种状态之间的转换只有两种可能：

1. 消去了一对结点。
2. 没有可以消去的结点，随机调整。

下面是这个有限状态机的示意图：
![](http://7xl294.com1.z0.glb.clouddn.com/连连看状态机.png)

这个是详细的流程图：
![](http://7xl294.com1.z0.glb.clouddn.com/连连看算法示意图.png)

这样，一个连连看的核心模型就完成了。

然后我们就可以继续搞定数据结构和算法了。

# 数据结构及存储

## 结构

完成连连看所需要的数据无非是每个图的图像和位置，那么我们如果把每个连连看看里的图像当成结点，那么每个结点应该至少有位置和内容。

## 存储

因为结点的位置不会发生变动，所以最省资源的还是静态的数组，在python里可以用双重列表。

然后对于图像而言，可以建立一个索引来指向图像，那么数组的元素保存图像的索引就可以完成对连连看的数据结构的存储。

当然，因为连连看需要的空间小，而且程序所要求的速度性能非常低，任性点直接每个节点都存储位置和图像，然后直接把结点随意塞到一个数组里也是一点问题都没有的。

# 算法

我们在流程图中可以看到，整个的过程就是两个判断和两个流程，我们的算法也就是实现这四个家伙，在这里我们只是考虑如何实现这些流程，到后面再来考虑如何做优化。

+ 实现消去一个对子
+ 实现调整位置
+ 判断是否还有结点
+ 判断是否死锁

***

下面我们来一个个讨论如何实现

**实现消去一对结点**

这里面最重要的算法就是计算两个结点之间能不能连通，这个有很多实现方法。我先抛砖引玉说一种思路。

> 遍历一个结点能连通的所有位置，每遍历一个位置观察对应结点是不是在这个位置上。

由规则2我们知道，连连看规则是连线之间不能有其他结点，并且路线不能弯折超过两次。

那么路线就可以分为三种层次--没有弯折，弯折一次，弯折两次。可以用一个高度不超过3的树来表示这种结构。既然可以用树来表达，那么我们就可以用树的深度优先搜索和广度优先搜索了。

如果用广度优先，那么我们先可以先找出所有不用弯折就可以到达的位置，把这些位置存着，如果这途中没有找到，那么这些点重复上面的步骤，找出所有弯折一次能到的位置，如果没找到，再重复。如果还没找到，那么就表示无法连通。

**确定死锁**

我们既然是学贵数学的，就应该把这个问题转化成已经解决过的问题。比如，我们可以很粗暴的直接遍历所有剩下的结点，看看是否都没有相连的结点。如果都没有，那么就表示死锁了。

**判断是否还有节点**

这个看数据结构，如果用的是数组的话，那么遍历整个数组，看看是不是每个位置都是空的。

**调整**

每次随机选出两个还有结点的位置，交换这两个位置的图案。

这样模型，结构和算法都已经完成了，然后我们就可以开始码代码测试了。

# 代码实现

这个连连看的demo已经实现了，只有最简陋的运行在命令行的程序，没有任何美化。不过所有的基础功能都已经实现了，算是连连看1.0完成了吧。

程序的python文件在我的[github/garage/lianliankan](https://github.com/Arnold-Hu/garage/blob/master/lianliankan/simple_lianlian.py)里,随便你复制粘贴或者clone代码都行，只有那一个文件。

这个文件可以直接import，开始游戏的那一段已经通过`if __name__ == '__main__'`给限定在测试用，当你把这个文件当模块用的时候，这部内容会自动忽略。

因为是1.0版，所以这个版本的实现可以说是非常仓促，没有任何优化，甚至为了通过测试，很多地方都冗余了，后面有时间会慢慢改进。

程序里注释了每个函数的功能，结合上说过的算法很容易知道整个运行逻辑。

ps：果然写一整个小项目的过程比写一个算法烦多了。。。第一次用pycharm来排bug。难得一次写几百行，还是这么简单的玩具代码，想想以后要写的东西，任重道远啊～

# todo
+ 代码实现  done
+ 效果展示
+ 优化的思考
++ 如何实现提示功能
++ 能不能优化搜索路径的步骤使得不需要每次判断相连都要重新搜索
++ 如何快速的确定死锁
++ 如何快速的判断是否还有结点
++ 如何减少执行这个程序需要的内存

其实对于上面的小程序，上面的优化都毫无必要，但是我们还是把他当成一个大工程来想想，锻炼一下～
